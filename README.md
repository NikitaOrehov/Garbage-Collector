# Сборщик мусора на основе mark and sweep
Алгоритм «Mark and sweep» — это классический алгоритм сборки мусора, который автоматически управляет памятью, освобождая пространство, занятое объектами, которые больше не используются программой. Он состоит из двух основных этапов: пометки (Mark) и сбора (Sweep).
### 1. Фаза пометки (Mark Phase):  
  - Определение корней: алгоритм начинается с набора «корневых» объектов. Корни — это объекты, которые напрямую доступны программе (например, глобальные переменные, локальные переменные в стеке, регистры процессора).  
  - Обход графа объектов: начиная с корневых объектов, алгоритм рекурсивно обходит граф объектов, помечая каждый объект, до которого он добирается, как «живой».  
  - Завершение маркировки: фаза маркировки завершается, когда алгоритм посетил и пометил все объекты, достижимые из корней.  
### 2. Фаза сметания (Sweep Phase):  
  - Линейный просмотр памяти: алгоритм проходит по всей области памяти (куче), в которой хранятся объекты.  
  - Проверка метки: для каждого объекта алгоритм проверяет, помечен ли он как достижимый.  
  - Освобождение памяти:  
    - Если объект не помечен, это означает, что на него нет ссылок из корней и он считается мусором. Алгоритм освобождает занимаемую им память, возвращая её в пул свободной памяти для дальнейшего использования.  
    - Если объект помечен, это означает, что он все еще используется программой. Алгоритм снимает с него пометку (сбрасывает бит пометки в 0), чтобы подготовить его к следующему циклу сборки мусора.  
  - Завершение подметания: фаза подметания завершается, когда алгоритм просматривает всю область памяти и освобождает память, занятую мусорными объектами.  
  
## плюсы и минусы
### Плюсы:  
  - Простота реализации  
  - Эффективное обнаружение циклического мусора  
  - Минимальные накладные расходы на дополнительную память  
### Минусы:  
  - недостатком является необходимость приостанавливать выполнение программы на время работы алгоритма  
  - после многократных циклов сборки мусора в памяти могут образовываться небольшие несвязные блоки свободной памяти (фрагментация).   
  - В некоторых ситуациях может обнаруживать мусор не с первого раза или не обнаружить вовсе  
## как работает данный GC

### создание объекта:  
  - Выделяем память
  - Вызываем перегруженный new
  - Добавляем выделенный адрес в hash map  
### mark:
  - происходит поиск корней. Поиск происходит путём прохода по стеку и сравнению хранящихся там адресов с адресами в hash map. При совпадении помечаем объект, как живой
  - ищем дочерние объекты каждого корня. Для этого проходит по стеку от адреса объекта до адреса плюс размер.  
### sweep:
  - Проходим по всем объектам hash map
  - Проверяем живой ли объект
    - если живой, помечаем как не живой
    - если не живой, удаляем объект

## пример работы

```rb
int main(int argc,  char* argv[]) {
    gcInit();
    A* bb = new A;
    int* aa = new int;
    bb->a = nullptr;
    gc();
}
```
gcInt() необходимо писать в начале программы для сохранения указателя на начала(почти) стека. А для вызова сборщика нужно вызывать функцию gc().






  

